= Beans
:toc:

{empty} +

===== Spring Bean

* any object init through ðŸŒ± container.

{empty} +

===== `@Bean`

Indicates that a method produces a bean to be managed by the Spring container. +
@Bean annotation also can be used with parameters like name, initMethod and destroyMethod.

* name â€“ allows you give name for bean
* initMethod â€“ allows you to choose method which will be invoked on context register
* destroyMethod â€“ allows you to choose method which will be invoked on context shutdown

{empty} +

===== Spring Container

image:img/spring-container.png[]

* ðŸŒ± container manages the lifecycle of ðŸŒ±â˜•s.
* 2 main container types :
** `BeanFactory`
*** provides _DI_ capability, see `./di/../Di.adoc`
** `ApplicationContext` `extends` `BeanFactory`, adds :
*** MessageSource
*** Access to resources
*** Event propagation to beans
*** Loading of multiple (hierarchical) contexts
* 5 main container impl (see `./di/../Di.adoc`) :
** `FileSystemXmlApplicationContext`
** `ClassPathXmlApplicationContext`
** `AnnotationConfigApplicationContext`
** `XmlWebApplicationContext`
** `AnnotationConfigWebApplicationContext`

{empty} +

===== Container Lifecycle

1. ðŸ“¦ is created.
1. ðŸ“¦ reads config data.
3. â˜• definitions are created.
4. `BeanFactoryPostProcessor` updates definitions.
5. â˜• are instantiated using definitions.
6. injections are applied to â˜•s.
7. `BeanPostProcessor` updates â˜•
** if initialization callbacks exist, invoke, and goto 7.
8. â˜•s ready.
9. Application shut down is initialized.
10. The Spring container is closed.
11. Destruction callbacks are invoked on the singleton Spring beans in the container.

{empty} +

===== Container Lifecyle Details

(2) configs:

* XML -> XML
* Java -> @Configuration
* Annotation -> @Component

(4) there are many `BeanFactoryPostProcessor` can specify order via `@Order`

{empty} +

===== 5 Bean Scopes

[cols="1,4"]
|===
| singleton | > one instance per container +
> **default** scope
| prototype | new instance each time bean is requested
| request | new instance for each HTTP request.
| session | new instance for each HTTP session.
| global-session | for portlet apps
|===

====== Singleton

* ðŸŒ± wraps `@Configuration` calsses in proxy, and intercepts calls to `@Bean` methods, and checks if instance exists.
** thus methods can`t be final.

{empty} +

===== Initialization

* eager (on startup)
** singleton, portlet(?)
* lazy (on demand)
** singleton (@Lazy), all others
* `@Lazy` can apply to:
** `@Bean`
** `@Configuration` (then applies to all `@Bean`)
** `@Component`

{empty} +

===== 3 Bean Configuration Paths

* XML : `resources/foo.xml`
* Java (Spring 3.0+) : `@Configuration`, `@ComponentScan`, `@Bean`.
* Annotation : `@Service` , `@Component`, `@Scope`. (only Annotatin supports `@Autowire`)

{empty} +

===== Spring Bean Life Cycle

* see `./beanlife/../BeanLife.adoc`.

===== IoCC (IoC Container)

* is responsible for injecting the dependency.
* is responsible to instantiate, configure and assemble the objects.
** to instantiate the application class
** to configure the object
** to assemble the dependencies between the objects

{empty} +

===== Dependency Injection (DI)

* See `design/decoupling/levels/Levels.adoc` for an overview.
* DI is the opposite of _dependency lookup_
** resource is retrieved after demand
** `A obj = new AImpl();`
** `A obj = A.getA(); // using factory`
** tight coupling
** complicates testing
* ðŸŒ± supports
** Constructor injection
** Method injection (by setter)

{empty} +

===== Post Processors

* `@BeanFactoryPostProcessor` called:
** after bean definitions have been loaded
** before any bean has been initialized
** allows customizing beans, even eager-initializing ones
* `@BeanPostProcessor` called:
** after each bean has been initialized
** thus
*** during startup for singleton beans
*** on demand for prototype beans

{empty} +

==== Shutdown

* 2 ways
** appcontext.close()
** appcontext.registerShutdownHook()
* web
** ContextLoaderListener impl ServletContextListener
** ContextLoaderListener receives ServletContextEvent when web container stops the web application
* same for boot

==== Profiles
