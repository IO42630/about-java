= Beans
:toc:

{empty} +

===== Spring Bean

* any object init through ðŸŒ± container.

{empty} +

===== `@Bean`

Indicates that a method produces a bean to be managed by the Spring container. +
@Bean annotation also can be used with parameters like name, initMethod and destroyMethod.

* name â€“ allows you give name for bean
* initMethod â€“ allows you to choose method which will be invoked on context register
* destroyMethod â€“ allows you to choose method which will be invoked on context shutdown

{empty} +

===== Spring Container

image:img/spring-container.png[]

* ðŸŒ± container manages the lifecycle of ðŸŒ±â˜•s.
* 2 main container types :
** `BeanFactory`
*** provides _DI_ capability, see `./di/../Di.adoc`
** `ApplicationContext` `extends` `BeanFactory`, adds :
*** MessageSource
*** Access to resources
*** Event propagation to beans
*** Loading of multiple (hierarchical) contexts
* 5 main container impl (see `./di/../Di.adoc`) :
** `FileSystemXmlApplicationContext`
** `ClassPathXmlApplicationContext`
** `AnnotationConfigApplicationContext`
** `XmlWebApplicationContext`
** `AnnotationConfigWebApplicationContext`

{empty} +

===== Container Lifecycle

1. ðŸ“¦ is created.
1. ðŸ“¦ reads config data.
3. â˜• definitions are created from the config data.
4. `BeanFactoryPostProcessor` processes â˜• definitions.
5. â˜• are instantiated by ðŸ“¦ using â˜• definitions.
6. â˜• are configured and assembled. +
Property values and dependencies are injected into the â˜• by the container.
7. `BeanPostProcessor` processes â˜•, invokes any initialization callbacks.
8. The application runs.
9. Application shut down is initialized.
10. The Spring container is closed.
11. Destruction callbacks are invoked on the singleton Spring beans in the container.

{empty} +

===== 5 Bean Scopes

[cols="1,4"]
|===
| singleton | > one instance per container +
> default scope
| prototype | new instance each time bean is requested
| request | (~prototype) new instance for each HTTP session.
| global-session | for portlet apps
|===

{empty} +

===== Initialization

* eager (on startup)
** singleton, portlet(?)
* lazy (on demand)
** singleton (@Lazy), all others

{empty} +

===== 3 Bean Configuration Paths

* XML : `resources/foo.xml`
* Annotation : `@Service` , `@Component`, `@Scope`.
* Java (Spring 3.0+) : `@Configuration`, `@ComponentScan`, `@Bean`.

{empty} +

===== Spring Bean Life Cycle

* see `./beanlife/../BeanLife.adoc`.

===== IoCC (IoC Container)

* is responsible for injecting the dependency.
* is responsible to instantiate, configure and assemble the objects.
** to instantiate the application class
** to configure the object
** to assemble the dependencies between the objects

{empty} +

===== Dependency Injection (DI)

* See `design/decoupling/levels/Levels.adoc` for an overview.
* DI is the opposite of _dependency lookup_
** resource is retrieved after demand
** `A obj = new AImpl();`
** `A obj = A.getA(); // using factory`
** tight coupling
** complicates testing
* ðŸŒ± supports
** Constructor injection
** Method injection (by setter)

{empty} +

===== Post Processors

* `@BeanFactoryPostProcessor` called:
** after bean definitions have been loaded
** before any bean has been initialized
** allows customizing beans, even eager-initializing ones
* `@BeanPostProcessor` called:
** after each bean has been initialized
** thus
*** during startup for singleton beans
*** on demand for prototype beans
