= Beans
:toc:
:toclevels: 5

{empty} +

=== Spring Bean

* any object init through üå± container.
* attributes:
- `autowireCandidate` : skip
- initMethod ‚Äì allows you to choose method which will be invoked on context register
- destroyMethod ‚Äì allows you to choose method which will be invoked on context shutdown
- name ‚Äì allows you give name for bean
- value : alias for name
* ‚òï ID is not an attribute -> auto by spring -> class name with first letter lower case

{empty} +

===== `@Bean`

Indicates that a method produces a bean to be managed by the Spring container. +
@Bean annotation also can be used with parameters like name, initMethod and destroyMethod.

* can set attributes via parameters

{empty} +

=== Spring Container

image:img/spring-container.png[]

* üå± container manages the lifecycle of üå±‚òïs.
* 2 main container types :
** `BeanFactory`
*** provides _DI_ capability, see `./di/../Di.adoc`
** `ApplicationContext` `extends` `BeanFactory`, adds :
*** MessageSource
*** Access to resources
*** Event propagation to beans
*** Loading of multiple (hierarchical) contexts
* 5 main container impl (see `./di/../Di.adoc`) :
** `FileSystemXmlApplicationContext`
** `ClassPathXmlApplicationContext`
** `AnnotationConfigApplicationContext`
** `XmlWebApplicationContext`
** `AnnotationConfigWebApplicationContext`

{empty} +

===== Container Lifecycle

1. üì¶ is created.
1. üì¶ reads config data.
3. ‚òï definitions are created.
4. `BeanFactoryPostProcessor` updates definitions.
5. ‚òï are instantiated using definitions.
6. injections are applied to ‚òïs.
7. `BeanPostProcessor` updates ‚òï
** if initialization callbacks exist, invoke, and goto 7.
8. ‚òïs ready.
9. Application shut down is initialized.
10. The Spring container is closed.
11. Destruction callbacks are invoked on the singleton Spring beans in the container.

{empty} +

===== Container Lifecyle Details

(2) configs:

* XML -> XML
* Java -> @Configuration (programmatic)
* Annotation -> @Component (declarative)

(4) there are many `BeanFactoryPostProcessor` can specify order via `@Order`

{empty} +

===== 5 Bean Scopes
* custom scopes can be created using the `Scope` interface.
* üåê scopes only valid with web-aware app-ctx

[cols="1,4"]
|===
| singleton | > one instance per container +
> **default** scope
| prototype | new instance each time ‚òï is requested
| üåê request | new instance for each HTTP request.
| üåê session | new instance for each HTTP session. imagine shopping-cart.
| global-session | for portlet apps
| üåê application | lifecycle of a `ServletContext`
| üåê websocket | lifecycle of a `WebSocket`
|===

====== Singleton

* üå± wraps `@Configuration` calsses in proxy, and intercepts calls to `@Bean` methods, and checks if instance exists.
** thus methods can`t be final.

{empty} +

===== Initialization

* eager (on startup)
** singleton, portlet(?)
* lazy (on demand)
** singleton (@Lazy), all others
* `@Lazy` can apply to:
** `@Bean`
** `@Configuration` (then applies to all `@Bean`)
** `@Component`

{empty} +

===== 3 Bean Configuration Paths

* XML : `resources/foo.xml`
* Java (Spring 3.0+) : `@Configuration`, `@ComponentScan`, `@Bean`.
* Annotation : `@Service` , `@Component`, `@Scope`. (only Annotatin supports `@Autowire`)

{empty} +

===== Spring Bean Life Cycle

* see `./beanlife/../BeanLife.adoc`.

===== IoCC (IoC Container)

* is responsible for injecting the dependency.
* is responsible to instantiate, configure and assemble the objects.
** to instantiate the application class
** to configure the object
** to assemble the dependencies between the objects

{empty} +

===== Dependency Injection (DI)

* See `design/decoupling/levels/Levels.adoc` for an overview.
* DI is the opposite of _dependency lookup_
** resource is retrieved after demand
** `A obj = new AImpl();`
** `A obj = A.getA(); // using factory`
** tight coupling
** complicates testing
* üå± supports
** Constructor injection
** Method injection (by setter)

{empty} +

===== Post Processors

* `@BeanFactoryPostProcessor` called:
** after bean definitions have been loaded
** before any bean has been initialized
** allows customizing beans, even eager-initializing ones
* `@BeanPostProcessor` called:
** after each bean has been initialized
** thus
*** during startup for singleton beans
*** on demand for prototype beans

{empty} +

==== Shutdown

* 2 ways
** appcontext.close()
** appcontext.registerShutdownHook()
* web
** ContextLoaderListener impl ServletContextListener
** ContextLoaderListener receives ServletContextEvent when web container stops the web application
* same for boot

==== Profiles

=== Configuration

===== @Conditional

* used to selectively load Beans or Configurations

[cols="1,2"]
|===
| `@Conditional(FooCondition.class)` | use custom `FooCondition` impl `Condition`
| `@ConditionalOnClass` | create ‚òï if class available on classpath
| `@ConditionalOnMissingClass` |
| `@ConditionalOnBean` |
| `@ConditionalOnMissingBean` | create ‚òï if other  ‚òï missing
| `@ConditionalOnProperty` |
| `@ConditionalOnMissingProperty` |
| `@ConditionalOnWebApplication` |
| `@ConditionalOnMissingWebApplication` |
|===
