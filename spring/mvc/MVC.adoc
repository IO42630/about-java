= Spring MVC
:toc:
:toclevels: 5


=== View Resolver

* In Boot `WebMvcAutoConfiguration` automatically configures the following bean in the application context:
** `InternalResourceViewResolver`
** `BeanNameViewResolver`
* `ThymeleafViewResolver` also exists

=== Dispatcher Servlet

* front controller pattern
* central dispatcher servlet
** processes requests, delegates to delegates (@Controller )
** resolves views, maps view-names to view instances
** resolves exceptions
* enables centralized handling of security/exceptions
* web app, may define >1 dispatcher servelts,
** each with own namespace / app context / set of mappings/hadlers
* disp-servlet is init before any app-ctx

=== Web Container

* servlet 3.0:
** container uses impl of `ServletContainerInitializer` to config servlet container
* spring:
** `SpringServletContainerInitializer` implements `ServletContainerInitializer`
** `SpringServletContainerInitializer` calls `WebApplicationInitializer`
* spring 3.2:
** `WebApplicationInitializer` extends `AbstractAnnotationConfigDispatcherServletInitializer`
** `AbstractAnnotationConfigDispatcherServletInitializer` creates
*** `DispatcherServlet`
*** `ContextLoaderListener`
* 2 ways to init disp-servlet:
** xml
** extend `AbstractAnnotationConfigDispatcherServletInitializer`

=== Request Life

image:img/spring-mvc.svg[,70%]

[cols="1,8"]
|===
| (2) | Handler mapping decides the particular controller by using the URL and request parameters.
| (3) | Response data is wrapped in _model_. _view name_ is also returned.
| (4) | disp-servlet contains ☕ which impl `ViewResolver`. +
Asks those to resolve _view name_ until success.
|===

===== Model

* impl `Model`
* collection of key-value pairs
* represents state of the app
* is provided as param to the `View`

===== View

* impl `View`

[source]
public interface View {
    void render(
        @Nullable Map<String, ?> model,
        HttpServletRequest request,
        HttpServletResponse response
    ) throws Exception;
}

=== Trivia

* `spring-core` does not include `spring-mvc.jar`
** `spring-mvc` includes `spring-core`

=== Controller param types

* if not in below list
** if simple -> as if @RequestParam
** if complex -> as if @ModelAttribute

image:img/controller-param.png[]

==== Param Annotations

image:img/controller-anno1.png[]
image:img/controller-anno2.png[]

==== Method Anno

image:img/controller-anno3.png[]

=== View Types

JSP, Velocity, FreeMarker, JSF, Tiles, Thymeleaf,

=== Test

he goal of Spring MVC Test is to provide an effective way to test controllers by performing requests and generating responses through the actual DispatcherServlet.
Spring MVC Test builds on the familiar “mock” implementations of the Servlet API available in the spring-test module.
This allows performing requests and generating responses without the need for running in a Servlet container However, when writing such a unit test, much remains untested: for example, request mappings, data binding, type conversion, validation, and much more.
Furthermore, other controller methods such as @InitBinder, @ModelAttribute, and @ExceptionHandler may also be invoked as part of the request processing lifecycl
