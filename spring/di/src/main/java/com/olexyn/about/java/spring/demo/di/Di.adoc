= Dependency Injection
:toc:
:toclevels: 5

{empty} +

=== 3 Types of DI

* CDI (Constructor)
* SDI (Setter)
* FDI (Field, since 2.5 ~ @Autowired)

{empty} +

=== Ways to configure DI

* A : XML
** `beans.xml` -> `ParentBean`
*** CDI POJO
*** SDI method name pattern
* B : Java
** `@Configuration` -> `@Bean` +
`AppConfig` -> `ParentBean`
*** CDI POJO
*** SDI POJO
* C : Annotation
** `@Configuration` : this is config
** `@ComponentScan(path)` : where to scan for components
** `@Component` : this is component
** `@Autowired` : inject this, used on
*** CDI `@Autowired`
*** SDI `@Autowired`
*** FDI `@Autowired`

{empty} +

==== @Bean vs @Component

`@Bean` applies to methods, when using Java config. +
`@Component` applies to classes, when using Auto config.

{empty} +

=== @Import

* Import other `@Configuration`

=== @Qualifier

* used with @Autowire to distinguish bean instances of same type.
* differes based on 'way'
** B : 'qualifier' matches `@Bean qualifier()`
** C : 'qualifier' matches `@Component("qualifier")`
* can write own custome 'qualifiers' (skip due to scope, see https://www.baeldung.com/spring-autowire)

{empty} +

=== Trivia

* Annotation DI was added in Spring 2.5
* Annotation DI happens before XML, thus overriden if overlapping.

==== CDI vs SDI

* SDI can:
** skip injections
*** could be done with assigning `null` in CDI, +
but that is obviously not the intended use.
** swap injected bean without new instance of host bean
* overall logic applies:
** if always provided and bound to instance -> CDI
** if optional or swappable -> SDI

==== `@Autowired`

* If the type that is autowired is an `[]` or `Collection`, then the Spring container will collect all beans matching the value-type of the array in an array and inject the array.
* If type is `Map<String,Foo>`, spring will coolect all and set Bean name as Key.
* can have any access modifier (incl.`private`)
* CDI `@Autowired` is only required if injected â˜• has multiple constructor.
