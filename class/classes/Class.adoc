== Class
{empty} +

'''
==== General

* `.java` file can have 0..1 public top-level classes.
    ** `C-Error` if filename does not match name of public class.
* `this.var` references current and inherited members
    ** used do set apart instance/class variables from parameters/local variables
* `super.var` reference to inherited members
    ** used to call members of the Parent class from the Child class.
* `this(int i)` is used to call overloaded Constructor.
* Java supports only single inheritance

{empty} +

'''
==== Ordering of Elements

[options=header]
|===
|Element|Example|Required|Placement
|Package declaration | `package foo;`|NO | First line in the file
|Import statements | `import bar.*;`|NO | After the package
|Class declaration | `public class C`| YES | After import
|Field declarations | `int i;`| NO | Any top-level element in class
|Method declarations | `void method()` | NO |  Any top-level element in class
|===
{empty} +

'''
==== Constructors
* The purpose of a _constructor_ is to initialize fields.
* Matches the name of the class.
* May have different access modifiers.
    ** Overloading rules do apply.
* If a user-declared constructor is present,
    ** then the default constructor is not declared in the background.
    *** Thus calling the default constructor `-> C-Error`.
    *** having a private constructor effectively disables the instantiation of the class from outside.
**** it can only be extended by inner classes.
* `this()` and `super()` must be the first statement in the constructor
    ** `Foo(){this();}` does not Compile, likewise other circular references caused by constructors.
* If no `this()` or `super()` are present, then the compiler inserts a `super()` in the background
    ** since compiler inserts super() the parent constructor is called in every child
* Relevant:
    ** Parent has no-default constructor
    ** Child has no (or no matching) constructor.
    ** C-Error, since compiler will insert call to default constructor of parent.
* super() refers to most direct parent
* see `about.basics.classes.Constructors`

'''

==== Order of Initialization
* aka _class loading_
* a `class` is initialized either when
    *** program starts
    *** static member of the class is referenced
    *** shortly before instance of class is created

===== Order
. `static`
    .. init `super` first (start with highest)
    .. `static` var declarations (in order of appearance)
    .. `static` initializers (in order of appearance)
. `instance`
    .. init `super` first
    .. instance var declaration (in order of appearance)
    .. instance initializers (in order of appearance)
    .. Initialize the constructor including any overloaded constructors referenced with `this()`.
        ... `this()` or `super()` if present
        ... default `super()`
. what ever instance method is called

'''

==== Reviewing Constructor Rules SKIP


{empty} +
{empty} +


=== Inheritance
* Only members are inherited.



==== Subtype and Supertype
* if X subtype of Y , then
    ** X, Y class -> X subclass of Y
    ** X, Y interface -> X subinterface of Y
    ** X class, Y interface -> X implements Y (directly or through superclass)

{empty} +

'''
==== Overload vs Override vs Hide vs Redeclare
[options=header, cols="1,2,1,1,1,1,2"]
|===
|    | member | modifier |name |param | return type| effect
|Overload | instance method | | same | __different__ | __any__ |
|Override | instance method | |  same | __same__ | __covariant__ | replaces the parent method.
|Hide | instance field, +
static field, +
static method | | same | same | covariant | replaces the member only +
if a Child reference type is used.
|Redeclare | | (both) private  | same | same | _any_ | is always ok, +
(accessing the member +
from outside the class +
is prohibited).
|Illegal | | !private | same | same | !covariant|
|===

* virtual method invocation : calling an abstract method in an abstract class, with confidence
that it will be implemented in child class.
* see also
** `method/Methods.adoc#Overriding`

{empty} +
{empty} +







{empty} +
{empty} +





=== Polymorphism
* See `about.basics.classes.Polymorphism`




==== 2 Types of Polymorphism
* Overloading (C-Time Poly) : resolved at C-Time
* Overriding (R-Time Poly) : resolved at R-Time
** Example below: +
    Compiler will check if all calls to `foo` are with param of type `Parent`. +
    Compiler will *not* check if all call to `foo` are with param of type `Child`. +
    If it so happens that `p` is not of type `Child` -> `R-Error`.
*** Similarly if p was a local variable +
Basically when we write Parent p = new Child(); +

[source,java]
void foo(Parent p){
    Child c = (Child) p;
}
//
Parent p = new Child1(); // the compiler only checks if the object can match the reference,
// and forgets the rest.
Interface i = (Interface) p; // child may implement interface or not - the compiler doesn't remember
// -> R-Error (if Child1 doesn't happen to be implementing Interface)
Chi1d1 c = new Child2(); // to the compiler it is very clear, that Child2 can neither implement Child1
// (as Child1 is a class), nor extend Child1 (since Chld2 already extends Parent).
// -> C-Error

* type of _object_ (in memory)
    ** immutable
* type of reference (data type)
    ** determines API
* ??? is casting nothing more than reclaiming the full api of the child class


{empty} +
{empty} +

'''
=== Abstract Classes
|===
| `classes.AbastractDemo.java`
| `interfaces.Interfaces.adoc`
|===

* abstract class may contain concrete members
** concrete class may NOT contain abstract members
* abstract methods
** without body: `abstract void foo();`
** does not define an implementation upon declaration
** must be overridden in first _concrete class_
*** overriding rules _DO_ apply
* `abstract_class` classes may contain anything an concrete class contains
** not true vice-versa


==== Constructors in Abstract
* main difference:
    * can only be called by instantiating subclass
* see `about.basics.classes.AbstractDemo`






{empty} +
{empty} +


=== Enums
* Abbreviation: `Enum` will be used as placeholder what the "enum-name".
* An enum is a very fancy class, with a very fancy constructor
|===
|The constructor are declared similar to an array (despite being top-level constructs)|
`public enum Enum { A, B, C, D}`
|An enum constant ist at the same time an enum instance.|
`Enum instance = Enum.A;`
|It includes an `toString()` |
`System.out.println(Enum.A);     // A`
|And can be compared with `==`|
`instance == Enum.A; // true`
2+| As an instance it has access to the following instance methods:
2+|`Enum.A.name()` returns String (same as `Enum.A.toString()`)
2+|`Enum.A.ordinal()` returns linear position of enum constant
2+|Apart from that the Enum hast `static` methods:
2+|`static enum[] values()` returns array
2+|`Season.valueOf("SUMMER")` returns instance that matches param, as if reverse of `Enum.SUMMER.name()`.
2+| also enums can't be extended
| Enums can contain Java code | > in block after each constant +
> after `;` after all constants have been listed (see below)
|===

[source,java]
public enum Season3 {
    WINTER { public void printHours() { System.out.println("short hours"); }
    },
    SUMMER { public void printHours() { System.out.println("long hours"); }
    },
    SPRING,
    FALL;
    public void printHours() { System.out.println("default hours");
    }
}


{blank} +

=== Poly and Ifaces
* when using abstract reference (e.g. inface) for concrete class
    ** wish to access memeber which exist in concrete class only
    ** explicit cast from e.g. infterface to class
        *** mus be compatible
* `instanceof`
    ** if reference type is final compiler will detect
    ** if reference type is abstract it might be extended to become an instance of
        *** thus compiler can't check

==== Inner Classes / Interfaces
* member of a class
* can have all 4 access modifiers ( top-level classes/interfaces can only be public/default)
* can't contain static methods


{empty} +
{empty} +


=== Nesting
All 4 Types are considered nested. Non-static nested classes are called inner classes.

[options=header]
|===
| 4 Types| static nested | member inner | local inner | anon inner
| 2+| same level as fields 2+|within method
| | static | instance | | without name
| access modif 2+| all 2+| none, already local to method
| can extend, implement, +
or be abstract, final 3+| yes | no, assigned to one super or interface at declaration
|access to instance members of enclosing class +
(incl. private vars) | NO 3+|YES
|access local var of enclosing class 2+|NO 2+|YES, if final or effectively-final.
|declare static methods | YES 3+|NO
|===

TODO at page 26ff








